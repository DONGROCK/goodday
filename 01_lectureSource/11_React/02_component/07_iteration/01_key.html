<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script crossorigin src='https://unpkg.com/react@18/umd/react.development.js'></script>
    <script crossorigin src='https://unpkg.com/react-dom@18/umd/react-dom.development.js'></script>
    <script src='https://unpkg.com/@babel/standalone/babel.min.js'></script>

</head>

<body>
    <div id='root'></div>
<!-- 
    배열 등을 이용하여 반복적인 컴포넌트를 렌더링 하는 방법
    arr.map(callback) 인자로 콜백함수를 받는다.
    -callback함수의 파라미터로 전달 된 배열 내 각 요소를 원하는 규칙에 따라 변환 후
    그 결과로 새로운 배열을 반환한다.
    
    callback : 새로운 배열 요소를 생성하는 규칙을 담은 함수로 파라미터는 3가지를 가질 수 있다.
    - currentValue : 현재 처리하고 있는 요소
    - index : 현재 처리하고 있는 요소의 index값
    - array : 현재 처리하고 있는 원본 배열
 -->
    <script type='text/babel'>
        // const numbers = [1,2,3,4,5];
        // const results = numbers.map((num) => num * num);
        // console.log(results);

        // const fruit = ['사과','바나나','복숭아']
        // fruit.map((currentValue, index, arry) =>{
        //     console.log('currentValue : ', currentValue );
        //     console.log('index : ', index);
        //     console.log('array : ', arry );
        // })

        //전역스코프 에서 상수로 names 값 선언
        const names = ['홍박사','유박사','블랙핑크','투와이스','스눕독']
        
        
        //props로 매개변수를 쓰겠다. {} 속성에 {names}라는 것이 나올것
        function Items({names}){
                // names를 출력시 배열형태로 된 값이 콘솔에 출력
            console.log("names = ",names);
            // names를 map형식으로 변환
            // 배열을 순환하며 반복 출력
            return(
                <ul>
                    names
                    {names.map(name =>(
                        <li>{name}</li>
                    ))}
                </ul>
            )

        }


        ReactDOM.createRoot(document.getElementById('root')).render(<Items names={names}/>);
    </script>

    <!-- 
        key란?
        리엑트에서 key는 컴포넌트 배열을 렌더링 했을 때 어떤 원소에
         변동이 있는지를 알아내기 위해 사용하는 식별자 역할을 한다.
        
         key가 존재하지 않을 때는 가상DOM이 실제 DOM과 비교하는 (diff) 과정에서 리스트를
         순차적으로 다 비교해 가며 변화를 감지한다.

        하지만 key가 존재한다면 이 값을 이용하여 어떤 변화가 일어났는지를 더 빨리 감지할 수 있다.
     -->
</body>

</html>